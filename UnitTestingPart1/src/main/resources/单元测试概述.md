什么是单元测试？
最小可测试单元的检查与验证，人为规定的最小被测功能模块
单元测试是软件开发过程中进行的最低级别的测试活动
软件的独立单元将在与程序的其他部分相隔离的情况下进行测试

为什么要写单元测试？
有效降低Bug
文档记录
回归性， 可以快速进行测试，可以随时随地快速进行测试

什么时候写单元测试？
- 具体实现代码之前，TDD
- 具体实现与代码同步进行
  - 少量功能代码
  - 单元测试
  - 重复执行，直到完成
- 编写完成后再写单元测试

TDD驱动的优点，缺点
优点：“小”单测覆盖，可读性，维护性好
缺点：粒度过大， 会浪费很多时间
具体实现与代码同步进行的优点，缺点
优点：“小”单测覆盖，可读性，维护性好
缺点：不断迭代完成测试
编写完后单元测试的优点，缺点
优点：可以一口气梳理所有的逻辑
缺点：事后编写的单元测试“粒度”都比较粗

单元测试要写多细（哪些代码需要单元测试覆盖）？
- 有效
- 逻辑复杂
- 容易出错
- 不易理解
- 公共代码
- 核心业务代码

单元测试的相关概念
被测系统
正在被测试的系统，SUT，测试系统能否正确操作
测试依赖组件
被测系统依赖的组件，UserService单测 -> UserDao
测试替身
实际系统测试依赖外部对象， 我们可以通假对象作为SUT的依赖对象，降低单元测试的复杂性和可实现性
测试替身的类型
Test stub
为SUT提供数据的假对象
Fake object
实现简单功能的假对象
Mock object
模拟实际对象，校验Mock object方法调用是否符合预期
Dummy object
没有被使用到，仅仅用来填充参数列表的对象
Test Spy
真实的Java对象， 返回一个包装后的新对象

mock与spy的区别：
mock是无中生有地生出一个完全虚拟对象， 所有方法虚拟；
spy是现有类基础上包装的对象，即使没有重写spy方法， 这些方法实现其实都是调用的被包装的对象的方法

Test fixture
运行测试程序所需要的先决条件，即被测对象进行测试时所需要的一切东西

测试用例
进行测试的一个用例程序， 用于进行相关的测试

测试套件
通过TestSuit对象将多个测试用例组装成一个测试套件， 测试套件批量运行